# 
# This file is generated by Chef
# Do not edit, changes will be overwritten 
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; only version 2 of the License is applicable.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# Authors:
#   David Crane <davidc at donorschoose.org>
#
# About this plugin:
#   This plugin uses collectd's Python plugin to record SCSI S.M.A.R.T. stats
#
# collectd:
#   http://collectd.org
# collectd-python:
#   http://collectd.org/documentation/manpages/collectd-python.5.shtml

########################################################################
# To configure the plugin, you must specify the full path to the
# arcconf utility. This assumes there is a single controller on the box.
#
#   <Plugin python>
#      ModulePath "/path/to/modules"
#      Import "smartctl"
#
#      <Module "smartctl">
#        SmartctlCmd "/usr/sbin/smartctl"
#      </Module>
#   </Plugin>
#
# The recipe[collectd::attribute_driven] will build conf.d/python.conf
# for you with the configuration above if you define these attributes
# in a roles/*.json file:
#
#   default_attributes ({
#     "collectd" => {
#       "plugins" => {
#         "python" => {
#           "template" => "python.conf.erb",
#           "config" => {
#             # One for each custom module script:
#             "smartctl" => {
#               "SmartctlCmd" => "/usr/sbin/smartctl",
#               "ScsiDrives" => [ "sg1", "sg2", "sg3", "sg4", "sg5", "sg6"]
#             }
#           }
#         }
#       }
#     }
#   })

######################################################################
import collectd, os, re, array

# Adaptec's arcconf executable. Override in config by specifying 'ArcconfCmd'.
SMARTCTL_CMD = '/usr/sbin/smartctl'
SCSI_DRIVES = []

def configure_callback(conf):
    """Receive configuration block"""
    global SMARTCTL_CMD
    global SCSI_DRIVES
    for node in conf.children:
        if node.key == 'SmartctlCmd':
            SMARTCTL_CMD = node.values[0]
        elif node.key == 'ScsiDrives':
            SCSI_DRIVES.append(node.values[0])
        else:
            collectd.warning('raid plugin: Unknown config key: %s.'
                             % node.key)

######################################################################
  # See /opt/collectd/share/collectd/types.db for all pre-defined Type
  # names. Use a GAUGE Type to report a number as is.
  # 
  # Use a COUNTER or DERIVE Type if the number should be stored in graphite
  # as a per-second rate. A COUNTER is a continuously incrementing counter
  # with legitimate overflow wrap detection at the 32bit or 64bit border.
  # A counter reset (as opposed to overflow wrap) should be detected, too.
  # A DERIVE with min=0 is similar, without the overflow check, and would
  # be something that fluctuates like a queue length.

def dispatch_value(value, plugin_instance, type, type_instance):
    """Dispatch a value to write_graphite"""

    val = collectd.Values(plugin='smartctl')
    val.plugin_instance = plugin_instance
    val.type = type
    val.type_instance = type_instance
    val.values = [value]

    # send high-level values as ...plugin-plugin_instance.type-type_instance
    val.dispatch()

########################################################################
# Regex for matching and parsing lines of smartctl output

# /usr/sbin/smartctl -H -d scsi /dev/sg1
# SMART Health Status: OK

c_status_re = re.compile('^SMART Health Status:\s*(.*)$')

########################################################################
# /usr/sbin/smartctl -A -d scsi /dev/sg1
# Current Drive Temperature:     26 C
# Drive Trip Temperature:        68 C
# Elements in grown defect list: 0
# Vendor (Seagate) cache information
#   Blocks sent to initiator = 405609328
#   Blocks received from initiator = 1399390054
#   Blocks read from cache and sent to initiator = 1558535727
#   Number of read and write commands whose size <= segment size = 475768764
#   Number of read and write commands whose size > segment size = 563
# Vendor (Seagate/Hitachi) factory information
#   number of hours powered up = 25938.12
#   number of minutes until next internal SMART test = 34

c_temp_re = re.compile('^Current Drive Temperature:\s*([0-9]+) C$')
c_glist_re = re.compile('^Elements in grown defect list:\s*([0-9]+)$')

########################################################################
# /usr/sbin/smartctl -l error -d scsi /dev/sg1
# Error counter log:
#            Errors Corrected by           Total   Correction     Gigabytes    Total
#                ECC          rereads/    errors   algorithm      processed    uncorrected
#            fast | delayed   rewrites  corrected  invocations   [10^9 bytes]  errors
# read:   3449928079       15         0  3449928094   3449928094      43999.159           0
# write:         0        0         0         0          0      44725.281           0
# verify:       93        0         0        93         93          0.000           0
# 
# Non-medium error count:       23

c_errorlog_re = re.compile('^(read|write|verify):\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9\.]+)\s+([0-9]+)$')
c_nonmedium_re = re.compile('^Non-medium error count:\s*([0-9]+)$')

########################################################################
def read_callback():

    # Test each drive in turn
    for drive in SCSI_DRIVES:
        # -H
        # SMART Health Status: OK
        non_optimal_status = 1   # Assume non-optimal until seen

        # -A
        # Current Drive Temperature:     26 C
        centigrade = 0

        # -A
        # Elements in grown defect list: 0
        glist_elements = 0

        # -l error
        #            Errors Corrected by           Total   Correction     Gigabytes    Total
        #                ECC          rereads/    errors   algorithm      processed    uncorrected
        #            fast | delayed   rewrites  corrected  invocations   [10^9 bytes]  errors
        # read:   3449928079       15         0  3449928094   3449928094      43999.159           0
        # write:         0        0         0         0          0      44725.281           0
        # verify:       93        0         0        93         93          0.000           0
        # Those will be added into some buckets:
        delayed_ecc_corrected = 0
        retries_corrected = 0
        errors_uncorrected = 0

        # -l error
        # Non-medium error count:       23
        non_medium_errors = 0

        for line in os.popen4('%s -H -A -l error -d scsi /dev/%s' %
                (SMARTCTL_CMD, drive))[1].readlines():
            # Match the regexs
            cstatus = c_status_re.match(line)
            if cstatus:
                non_optimal_status = 1 if (cstatus.group(1) != "OK") else 0
            ctemp = c_temp_re.match(line)
            if ctemp:
                centigrade = int(ctemp.group(1))
            glist = c_glist_re.match(line)
            if glist:
                glist_elements = int(glist.group(1))
            errorlog = c_errorlog_re.match(line)
            if errorlog:
                delayed_ecc_corrected += int(errorlog.group(3))
                retries_corrected += int(errorlog.group(4))
                errors_uncorrected += int(errorlog.group(8))
                if (errorlog.group(1) == "read"):
                    total_errors_corrected = int(errorlog.group(5))
                    gigabytes_processed = float(errorlog.group(7))
            nonmedium = c_nonmedium_re.match(line)
            if nonmedium:
                non_medium_errors = int(nonmedium.group(1))

        # send high-level values as ...smartctl-sg1.gauge-non_optimal_status, etc
        dispatch_value(non_optimal_status, drive, 'gauge', 'non_optimal_status')
        dispatch_value(centigrade, drive, 'temperature', 'centigrade')

        # "All defects sent by the application client to the device server."
        # It's possible these correlate to smartctl 'medium_errors-uncorrected'
        # and to the raid.py 'current-medium_errors' counters.
        dispatch_value(glist_elements, drive, 'current', 'grown_defects')

        # This was 210102 on data2 /dev/sg2 on 2013-06-23, before Softlayer replaced.
        # There was nothing reported through the raid.py monitor, perhaps because
        # these errors were older?
        dispatch_value(non_medium_errors, drive, 'current', 'non_medium_errors')

        # The reported medium erros are "errors corrected with possible delays"
        # and "errors that are corrected by applying retries" (both sound like
        # near misses), plus "the total number of blocks for which an uncorrected
        # data error has occurred" (presumably terminating the transfer and
        # indicating to the OS that data is lost). These are normally small.
        dispatch_value(delayed_ecc_corrected, drive, 'current', 'medium_errors-delayed')
        dispatch_value(retries_corrected, drive, 'current', 'medium_errors-retried')
        dispatch_value(errors_uncorrected, drive, 'current', 'medium_errors-uncorrected')

        dispatch_value(total_errors_corrected, drive, 'current', 'lifetime-ecc_blocks_corrected')
        dispatch_value(total_errors_corrected, drive, 'counter', 'per_second-ecc_corrections')

        dispatch_value(gigabytes_processed, drive, 'current', 'lifetime-gigabytes_processed')
        dispatch_value((1000000000.0/1048576.0)*gigabytes_processed,
           drive, 'derive', 'per_second-megabytes_read')

        # I'm omitting one count of medium errors: the "fast ECC corrections,"
        # which are normally large.  Description from Seagate's SCSI manuals:
        #    Errors corrected without substantial delay. An error
        #    correction was applied to get perfect data (a.k.a., ECC
        #    on-the-fly). "Without Substantial Delay" means the
        #    correction did not postpone read- ing of later sectors
        #    (e.g., a revolution was not lost).

########################################################################
# register callbacks
collectd.register_config(configure_callback)
collectd.register_read(read_callback)
